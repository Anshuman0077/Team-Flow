import { RealtimeMessage, ThreadEvent, ThreadEventsSchema } from "@/app/(dashboard)/schemas/realtime";
import { orpc } from "@/lib/orpc";
import { InfiniteData, useQueryClient } from "@tanstack/react-query";
import usePartySocket from "partysocket/react";
import { createContext, ReactNode, useContext, useMemo } from "react";

const ThreadRealtimeContext = createContext< null | ThreadRealtimeContextValue>(null);



interface ThreadRealtimeProviderProps {
    children: ReactNode;
    threadId: string;
}

type ThreadRealtimeContextValue = {
    send: (event: ThreadEvent) => void;
   };


export function ThreadRealtimeProvider({threadId , children} : ThreadRealtimeProviderProps) {
    const queryClient = useQueryClient()

    type ThreadOptions = ReturnType<
    typeof orpc.message.thread.list.queryOptions
    >;

    type ThreadQueryData = Awaited<ReturnType<ThreadOptions["queryFn"]>>;
    const socket = usePartySocket({
        host:"https://teamflow-chat-realtime-yt.itzluciferaloneboy.workers.dev",
        room:`thread-${threadId}`,
        party: "chat",    
        onMessage(e) {
            try {
                const parsed = JSON.parse(e.data)

                const result = ThreadEventsSchema.safeParse(parsed)

                if (!result.success) {
                    console.log("Invalid Threads Events")
                    return;
                }
                const evt = result.data
                // console.log(evt);

                if (evt.type === "thread:reply:created") {
                    const replyObj = evt.payload.reply as RealtimeMessage
                    // Use the same key generated by orpc   
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: {messageId: threadId},
                    });

                    queryClient.setQueryData<ThreadQueryData>(listOptions.queryKey , (old) => {
                        if (!old) return old;

                        const reply = {
                          reactions: Array.isArray(replyObj.reactions) 
                           ? replyObj.reactions
                            : [],
                            ...replyObj,
                        } as ThreadQueryData["messages"][number]

                        return {
                            ...old,
                            messages: [...old.messages , reply],
                        };
                    },
                );
                return;
                }

                if (evt.type === "thread:reaction:updated") {
                    const {messageId , reactions, threadId: tid} = evt.payload;

                    if (tid !== threadId) {
                        return;
                    }
                    // Use the same key generated by orpc   
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: {messageId: threadId},
                    });

                    queryClient.setQueryData(listOptions.queryKey, (old) => {
                        if (!old) return

                        if (messageId === threadId) {
                            return {
                                ...old,
                                parentRow: {...old.parentRow, reactions},
                            };
                        }

                        return {
                            ...old,
                            messages: old.messages.map((m) => 
                                m.id === messageId ? {...m, reactions} : m
                            )
                        }
                    })


                    return;
                }
            } catch  {
                console.log("Somethign went wrong"); 
            }
        }
    });

    const value = useMemo<ThreadRealtimeContextValue>(() => {
        return {
            send: (event) => {
                socket.send(JSON.stringify(event))
            },
        };

    }, [socket])

    return (
        <ThreadRealtimeContext.Provider value={value}>
            {children}
        </ThreadRealtimeContext.Provider>
    );
}

export function useThreadRealtime() {
    
    const ctx = useContext(ThreadRealtimeContext);

    if (!ctx) {
        throw new Error("useThreadRealtime must be used within a ThreadrealtimeProvider");
    }
    return ctx;
}
export function useOptionalThreadRealTime(): ThreadRealtimeContextValue | null {
    return useContext(ThreadRealtimeContext)
}